# Overview

An alt docs site built using ChatGPT 'Deep Search' and CursorAI using publicly
available information.

**mp4split (Unified Packager)** is a command-line tool for preparing media content for streaming. It packages source MP4 files into segmented formats suitable for Adaptive Bitrate (ABR) playback (HLS, MPEG-DASH, Smooth Streaming, etc.), and can optionally encrypt content for DRM protection ([Unified Packager — Unified Streaming](https://docs.unified-streaming.com/documentation/package/index.html#:~:text=Prepare%20your%20media%20for%20Adaptive,CDN)). The output is ready to serve from a standard web server or CDN to a variety of devices. In a **static packaging** workflow, `mp4split` converts media files into the required segments and manifests for each streaming format in advance, duplicating the content for each format on disk ([Unified Packager — Unified Streaming](https://docs.unified-streaming.com/documentation/package/index.html#:~:text=Static%20packaging%20is%20the%20process,be%20part%20of%20the%20packaging)).

 ([Unified Packager — Unified Streaming](https://docs.unified-streaming.com/documentation/package/index.html)) *Unified Packager static packaging workflow: Source media (MP4) is processed by the packager into segmented outputs (HDS, HLS, MPEG-DASH, MSS), optionally with encryption/DRM. The packaged content is then stored on an origin server or CDN for delivery to end-user players.*

### Key Features

- **Multiple Streaming Formats:** Supports all industry-standard streaming formats – Apple HLS (both MPEG-TS and CMAF/fMP4), MPEG-DASH, HbbTV, Adobe HDS, and Microsoft Smooth Streaming (MSS/HSS) ([Unified Packager — Unified Streaming](https://docs.unified-streaming.com/documentation/package/index.html#:~:text=Key%20features)). This enables one tool to target a wide range of platforms.
- **Subtitle & Caption Support:** Comprehensive subtitle support. It can ingest and convert between WebVTT, SRT, TTML (IMSC1), and embedded closed captions (CEA-608/708) for inclusion in streams ([Unified Packager — Unified Streaming](https://docs.unified-streaming.com/documentation/package/index.html#:~:text=,608)). For example, SRT or WebVTT caption files can be packaged into fragmented MP4 subtitle tracks or converted between formats.
- **Codec Compatibility:** Handles the latest audio/video codecs and formats, including AV1, HEVC (H.265), H.264/AVC, as well as immersive audio like Dolby Atmos, Dolby AC-4, and DTS:X ([Unified Packager — Unified Streaming](https://docs.unified-streaming.com/documentation/package/index.html#:~:text=,608)). This ensures it can package modern high-quality content (up to 4K HDR).
- **DRM Integration:** Supports every major DRM system – FairPlay, PlayReady, Widevine, Marlin – via Common Encryption and format-specific encryption (e.g., SAMPLE-AES for HLS) ([Unified Packager — Unified Streaming](https://docs.unified-streaming.com/documentation/package/index.html#:~:text=,4%2C%20DTS%3AX)). You can encrypt streams during packaging, inserting DRM metadata so that one set of segments can be secured for multiple DRM schemes.

### Benefits

- **Command-Line Tool:** `mp4split` runs as a CLI application, so no always-on server component is needed for packaging ([Unified Packager — Unified Streaming](https://docs.unified-streaming.com/documentation/package/index.html#:~:text=,a%20web%20server%20for%20operation)). This makes it easy to script and integrate into existing media pipelines.
- **Flexible Deployment:** Can be deployed on-premises on bare metal, within containers (Docker), or in cloud environments (it's lightweight enough to run as a serverless function) ([Unified Packager — Unified Streaming](https://docs.unified-streaming.com/documentation/package/index.html#:~:text=,a%20web%20server%20for%20operation)). This flexibility allows integration into various build or encoding farms.
- **Easy Integration:** Being CLI-based, it fits well into automated workflows and CI/CD pipelines for media processing ([Unified Packager — Unified Streaming](https://docs.unified-streaming.com/documentation/package/index.html#:~:text=)). It can be invoked from scripts or other tools whenever new content needs packaging.
- **High-Quality Streaming:** Delivers the highest quality streams by supporting 4K HDR video, advanced audio formats, and accessibility tracks (multiple subtitles, audio descriptions) ([Unified Packager — Unified Streaming](https://docs.unified-streaming.com/documentation/package/index.html#:~:text=,formats%2C%20and%20add%20accessibility%20options)). This ensures compliance with broadcast and OTT requirements for quality and accessibility.
- **Content Protection:** Provides robust content protection options – encryption with support for multiple keys and key rotation for DRM ([Unified Packager — Unified Streaming](https://docs.unified-streaming.com/documentation/package/index.html#:~:text=subtitle%20and%20video%20formats%2C%20and,add%20accessibility%20options)). You can assign different keys per track or time segment and have the packager output the necessary license information, enhancing security.
- **Accessibility:** Broadens audience reach by allowing addition of closed captions, subtitles, and alternate audio (e.g., descriptive audio) into your streams ([Unified Packager — Unified Streaming](https://docs.unified-streaming.com/documentation/package/index.html#:~:text=,tracks%20for%20the%20visually%20impaired)). This makes it straightforward to include VOD or live content that meets accessibility standards.

## Installation & Setup

**Prerequisites:** Using Unified Packager (`mp4split`) requires a valid license key from Unified Streaming. Ensure you have obtained a license (e.g., an evaluation or purchased Base64-encoded key) and install it. The license key can be provided via a file or environment variable. For example, save the key to a file (e.g., `usp-license.key`) and either set the `UspLicenseKey` environment variable or use the `--license-key` option when running `mp4split` ([How to Install — Unified Streaming](https://docs.unified-streaming.com/installation/distributions.html#:~:text=The%20software%20requires%20a%20license,in%20Setting%20up%20a%20virtual)) ([License Key — Unified Streaming](https://docs.unified-streaming.com/installation/license.html#:~:text=It%27s%20also%20possible%20to%20set,key%60%20option)). Without a valid license, packaging may be disabled or run in a time-limited demo mode. Additionally, on Windows, make sure the **Microsoft Visual C++ Redistributable** is installed (all Unified Streaming packages depend on it) ([Installation on Windows (USP version 1.14.0 or later) — Unified Streaming](https://docs.unified-streaming.com/installation/distributions/windows-from-1.14.0.html#installation-windows-from-1-14-0#:~:text=other%20USP%20packages)). If you plan to use the **Manifest Edit** tool or certain DRM features, having Python 3.x installed (for manifest editing pipeline) may be required on Windows ([Installation on Windows (USP version 1.14.0 or later) — Unified Streaming](https://docs.unified-streaming.com/installation/distributions/windows-from-1.14.0.html#installation-windows-from-1-14-0#:~:text=In%20general%2C%20all%20USP%20packages,version%20of%20the%20Python%20interpreter)).

### Linux Installation

Unified Packager is available as a package for various Linux distributions:

1. **Add Package Repository:** Add Unified Streaming's APT/YUM repository for your Linux distribution (instructions are provided for Alpine, Ubuntu/Debian, Red Hat/CentOS/Rocky Linux, etc. in the official docs). For example, on Debian/Ubuntu, add the Unified Streaming repository to your apt sources list (the repository URL is provided by Unified Streaming). On Red Hat-based systems, add the provided YUM repository configuration.
2. **Install the `mp4split` Tool:** Once the repo is added, install via the package manager. For Debian/Ubuntu use: `sudo apt-get install mp4split`, for RHEL/CentOS use: `sudo yum install mp4split`, or on Alpine: `apk add mp4split`. This installs `mp4split` and any required dependencies (such as `unified_capture` and `unified_remix` tools) ([How to Install — Unified Streaming](https://docs.unified-streaming.com/installation/distributions.html#installation-on-linux-all-supported-distributions#:~:text=Alpine%3A)).
3. **Verify Installation:** After installation, you should be able to run `mp4split --version` (or simply `mp4split`) in the terminal to see the version and usage info. Ensure the license key is accessible to the tool. You can set the `UspLicenseKey` env variable in your shell or use `mp4split --license-key=/path/to/usp-license.key --show-license` to confirm the license is recognized ([License Key — Unified Streaming](https://docs.unified-streaming.com/installation/license.html#:~:text=Features%20and%20Expiry%20%2011)).
4. *(Optional)* **Manifest Edit Tool:** If you need to post-process manifests for statically packaged content, you can install the optional `manifest-edit` CLI tool. (On Linux: e.g., `sudo apt-get install manifest-edit` will install it if not already present ([How to Install — Unified Streaming](https://docs.unified-streaming.com/installation/distributions.html#installation-on-linux-all-supported-distributions#:~:text=When%20installing%20Unified%20Origin%2C%20Manifest,line%20tool)).)

### Windows Installation

For Windows, Unified Packager is distributed as a ZIP archive (there is no installer EXE). The high-level steps are:

1. **Download Package:** Download the ZIP for the Unified Packager (`mp4split`) from the official Unified Streaming stable releases site. The ZIP name is of the form `mp4split_<version>-<revision>.zip` – for example, `mp4split_1.14.0-1.zip` for version 1.14.0 ([Installation on Windows (USP version 1.14.0 or later) — Unified Streaming](https://docs.unified-streaming.com/installation/distributions/windows-from-1.14.0.html#installation-windows-from-1-14-0#:~:text=Changed%20in%20version%201,1.zip)). Ensure you choose the correct version matching your license (all components you use should be the same version to avoid incompatibility ([Installation on Windows (USP version 1.14.0 or later) — Unified Streaming](https://docs.unified-streaming.com/installation/distributions/windows-from-1.14.0.html#installation-windows-from-1-14-0#:~:text=Attention))).
2. **Create Install Directory:** Create a directory for Unified Streaming, e.g. `C:\Program Files\Unified Streaming\` (if upgrading from a previous version, stop any running services and rename the old installation folder first as a backup ([Installation on Windows (USP version 1.14.0 or later) — Unified Streaming](https://docs.unified-streaming.com/installation/distributions/windows-from-1.14.0.html#installation-windows-from-1-14-0#:~:text=,existing%20installation)) ([Installation on Windows (USP version 1.14.0 or later) — Unified Streaming](https://docs.unified-streaming.com/installation/distributions/windows-from-1.14.0.html#installation-windows-from-1-14-0#:~:text=,restored%20in%20case%20of%20emergency))).
3. **Install Prerequisites:** Install the necessary prerequisites for the components you plan to use. At minimum, install the **Visual C++ 2015-2022 x64 Redistributable** (if not already installed) since `mp4split` and related tools depend on it ([Installation on Windows (USP version 1.14.0 or later) — Unified Streaming](https://docs.unified-streaming.com/installation/distributions/windows-from-1.14.0.html#installation-windows-from-1-14-0#:~:text=In%20general%2C%20all%20USP%20packages,version%20of%20the%20Python%20interpreter)). If you will use any Apache web server modules (for dynamic packaging) or the `manifest-edit` tool, ensure Apache and/or Python are installed as needed ([Installation on Windows (USP version 1.14.0 or later) — Unified Streaming](https://docs.unified-streaming.com/installation/distributions/windows-from-1.14.0.html#installation-windows-from-1-14-0#:~:text=,or%20more%20other%20%20437)) (these are only needed if using those specific features).
4. **Unzip the Package:** Unzip the `mp4split` ZIP into your installation directory. The ZIP is self-contained – when extracted, it places the binaries and files into subfolders (e.g., `bin\` for executables and DLLs, `etc\` for config, `doc\` for README/License) ([Installation on Windows (USP version 1.14.0 or later) — Unified Streaming](https://docs.unified-streaming.com/installation/distributions/windows-from-1.14.0.html#installation-windows-from-1-14-0#:~:text=,Unified%20Streaming)) ([Installation on Windows (USP version 1.14.0 or later) — Unified Streaming](https://docs.unified-streaming.com/installation/distributions/windows-from-1.14.0.html#installation-windows-from-1-14-0#:~:text=,subdirectory%20of%20the%20installation%20directory)). After unzipping, you should see `mp4split.exe` in the `bin` subdirectory along with other tools and libraries.
5. **Update PATH:** Add the `bin` folder of the installation directory to the system `PATH` environment variable ([Installation on Windows (USP version 1.14.0 or later) — Unified Streaming](https://docs.unified-streaming.com/installation/distributions/windows-from-1.14.0.html#installation-windows-from-1-14-0#:~:text=,environment%20variable)). This allows you to run `mp4split` from any Command Prompt or PowerShell. You can edit the PATH via Control Panel → System → Environment Variables. (Also add the Python install path to PATH if using manifest editing, as indicated ([Installation on Windows (USP version 1.14.0 or later) — Unified Streaming](https://docs.unified-streaming.com/installation/distributions/windows-from-1.14.0.html#installation-windows-from-1-14-0#:~:text=,bin)).)
6. **Verify Operation:** Open a new Command Prompt and run `mp4split --version` or simply `mp4split`. It should display version info and usage, confirming that the tool and its required DLLs are accessible on your system ([Installation on Windows (USP version 1.14.0 or later) — Unified Streaming](https://docs.unified-streaming.com/installation/distributions/windows-from-1.14.0.html#installation-windows-from-1-14-0#:~:text=,programs%2C%20a%20reboot%20is%20needed)). If you see errors about missing DLLs, double-check that the Visual C++ runtime is installed and that PATH is set correctly.
7. **License Setup:** Ensure the `UspLicenseKey` environment variable is set (e.g., via System Properties → Environment Variables) or provide the `--license-key` flag with the path to your key file on each invocation so that the license is recognized on Windows ([License Key — Unified Streaming](https://docs.unified-streaming.com/installation/license.html#:~:text=It%27s%20also%20possible%20to%20set,key%60%20option)).

### macOS Usage

There is no native macOS installer for Unified Packager, but you can easily run it via Docker. Unified Streaming provides a Docker image for `mp4split` which can be used on macOS (or any system with Docker):

- **Install Docker:** Make sure Docker Desktop is installed on macOS. The Unified Packager Docker image requires Docker (and Docker Compose if using their demo setups ([Docker Express - Unified Streaming](https://docs.unified-streaming.com/installation/evaluation.html#:~:text=Docker%20Express%20,mp4split%20mod_smooth_streaming))).
- **Set License Environment:** Export your license key in the environment so the container can use it. For example, in your shell: `export UspLicenseKey=<YOUR_BASE64_LICENSE_KEY> ([License Key — Unified Streaming](https://docs.unified-streaming.com/installation/license.html#:~:text=export%20UspLicenseKey%3DYOUR_LICENSE_KEY_IN_BASE64))`.
- **Run the Container:** Use the `unifiedstreaming/mp4split:latest` image to run packaging commands. For example:

```bash
	docker run -it -e UspLicenseKey -v "$PWD":/data -w /data unifiedstreaming/mp4split:latest \
	mp4split -o output.mpd input.mp4
```

  This command passes the license key into the container and mounts the current directory to `/data` inside the container, then executes `mp4split` within the container on an `input.mp4` file, writing out results to the mounted volume ([License Key — Unified Streaming](https://docs.unified-streaming.com/installation/license.html#:~:text=,workdir%20%2Fdata%20%24IMAGE)). Adjust the `-o` output and input paths as needed. You can similarly run any `mp4split` command via Docker on macOS. This approach isolates the tool in a container, so you don't need a native Mac build.

- **Alternative:** As an alternative to Docker, you could run Unified Packager in a Linux virtual machine on macOS. However, using the official Docker image is the quickest way to get `mp4split` working on macOS.

## Commands & Usage

Unified Packager is used through the `mp4split` command. Its generic invocation syntax is:

```
mp4split -o <output_path> [options] <input_file1> [<input_file2> ...] [track-specific options]
```

This means you specify an output file name with `-o`, then provide one or more input files (typically MP4 or other supported media files), plus any global or track-level options ([Program Usage — Unified Streaming](https://docs.unified-streaming.com/documentation/package/usage.html#:~:text=mp4split%20,options)). The output format is usually inferred from the output file's extension or from specific packaging options. Below is a breakdown of common usage patterns, commands, and options:

- **Basic File Packaging:** The simplest use is to take a single MP4 and **fragment it for streaming**. For example, to fragment an MP4 for Smooth Streaming (Unified Origin) you might do:

```bash
mp4split -o movie.ismv movie.mp4
```

  This reads `movie.mp4` and outputs a fragmented MP4 (`.ismv`). Similarly, outputting to `.cmfv` (Common Media Fragmented Video) would produce CMAF fragments, or to `.ts` would produce MPEG-TS segments for HLS. In general, `mp4split` will produce **segmented media files** (fMP4 or TS segments) and sometimes a manifest depending on the options used.

- **Selecting Tracks:** By default, `mp4split` will include all tracks (video, audio, subtitles) from the input in the output unless told otherwise. You can **select or filter specific tracks** using track options:
  - `--track_id=<N>` – include only the track with ID N from the input (you can repeat this for multiple inputs).
  - `--track_type=<type>` – include only tracks of a certain type (`audio`, `video`, or `text`). For instance, `mp4split -o audio.isma input.mp4 --track_type=audio` will output an audio-only file (.isma for Smooth Streaming audio) ([Program Usage — Unified Streaming](https://docs.unified-streaming.com/documentation/package/usage.html#:~:text=mp4split%20,track_type%3Daudio)).
  - `--track_language=<lang>` – select tracks with a given language code (useful if an MP4 contains multiple audio languages).
  - `--track_filter='<expression>'` – use a custom expression to filter tracks by properties like bitrate or roles. For example, you can separate an *audio description* track from a main audio track:
  - `mp4split -o description.isma input.mp4 --track_filter='(roles contains "description")'` will extract only the audio track tagged with the role "description" (for descriptive audio) ([Program Usage — Unified Streaming](https://docs.unified-streaming.com/documentation/package/usage.html#:~:text=match%20at%20L570%20mp4split%20,track_filter%3D%27%28roles%20contains%20%22description)).
  - Conversely, `--track_filter='!(roles contains "description")'` could be used to get the complement (the regular audio without the description role) ([Program Usage — Unified Streaming](https://docs.unified-streaming.com/documentation/package/usage.html#:~:text=mp4split%20,track_filter%3D%27%28roles%20contains%20%22description)).

  These options help tailor the output to include only the needed streams. For instance, you might package video and audio into separate files or pick specific audio languages for different outputs.

- **Combining Multiple Inputs:** You can input multiple files to `mp4split` to **merge or multiplex tracks**. A common scenario is when you have separate audio and video files (e.g., an audio-only MP4 and a video-only MP4) and want to package them together:

```bash
  mp4split -o combined.ismv video.mp4 --track_id=1 audio.mp4 --track_id=1
```

In this example, the video MP4's track 1 and the audio MP4's track 1 are packaged into one output file `combined.ismv`. The order of inputs and their associated track options determines how tracks are picked. This approach is useful if your encoding workflow outputs separate audio/video files; `mp4split` can recombine them into a single set of segments/manifest. For instance, packaging separate files for video and audio into one DASH-ready fragmented MP4 is possible in one command ([Program Usage — Unified Streaming](https://docs.unified-streaming.com/documentation/package/usage.html#:~:text=mp4split%20,track_id%3D4)).

- **Output to Specific Formats:** The format of the output is often controlled by the output file extension or explicit packaging flags:

- **DASH:** To create MPEG-DASH content, you typically produce fragmented MP4 files for each track and an MPD manifest. You can either manually specify an `.mpd` as the `-o` output (and add all track files as inputs), or use the `--package_mpd` option. For example, `mp4split --package_mpd -o stream.mpd video.cmfv audio.cmfa` will generate a DASH MPD named *stream.mpd* that references the given video and audio CMAF files ([Packaging for MPEG-DASH — Unified Streaming](https://docs.unified-streaming.com/documentation/package/mpeg-dash.html#creating-the-media-presentation-description-file-mpd#:~:text=mp4split%20,dash.cmfv)). (If the media files were not pre-fragmented, `mp4split` can fragment them in the same step.)

- **HLS:** To package for Apple HLS, you typically want `.m3u8` playlists and segments. You can directly specify an output `.m3u8` for `-o` and use `--package_hls` to signal HLS mode. For example: `mp4split --package_hls -o playlist.m3u8 input.mp4` will generate a HLS media playlist (and the corresponding `.ts` or `.m4s` segments depending on settings) ([Packaging HTTP Live Streaming (HLS) with TS — Unified Streaming](https://docs.unified-streaming.com/documentation/package/hls.html#advanced-recipes#:~:text=mp4split%20,1500k.mp4)). You can also create a master playlist by providing multiple variant playlists as inputs (see *Multi-bitrate* in Advanced Features, or Example below).

- **Smooth Streaming (MSS):** Outputting to `.ism` (server manifest) and `.ismv`/`.isma` triggers Smooth Streaming packaging. Typically, you generate the fragmented files (`.ismv` for video, `.isma` for audio) with one command each, and then you might use another `mp4split` call to combine them into a server manifest. For instance: `mp4split -o video.ismv input.mp4 --track_type=video` and `mp4split -o audio.ismv input.mp4 --track_type=audio` to get separate tracks, then `mp4split -o stream.ism audio.ismv video.ismv` to produce an `.ism` manifest that indexes them ([Packaging for Unified Origin — Unified Streaming](https://docs.unified-streaming.com/documentation/package/package.html#package-mp4-to-fragmented-mp4-and-back#:~:text=match%20at%20L828%20mp4split%20,o%20main.ism%20audio.ism%20video.ism)).

- **HDS (Adobe HTTP Dynamic Streaming):** Use a `.f4m` manifest output with `.f4f` fragments. For example: `mp4split -o video.f4f input.mp4` and then `mp4split -o stream.f4m video.f4f audio.f4f` to create the F4M manifest. (HDS is less common now, but the tool supports it for legacy purposes.)

- In general, **`--package_<format>` options** exist for convenience (e.g., `--package_mpd`, `--package_hls`). These put `mp4split` into a mode to create the respective manifest/playlist and possibly apply format-specific defaults. Otherwise, you can control details with specific flags (like `--hls.client_manifest_version`, `--mpd.profile`, etc. in advanced use).

- **Encryption & DRM Options:** `mp4split` can encrypt content on the fly as it packages. Common options include:
  - `--cenc.key=<KID>:<Key>` – encrypt using Common Encryption (CENC) with the given Key ID and Key (in hex). This is a generic option that can apply to DASH (Widevine/PlayReady) or HLS fMP4 (FairPlay CBCS) depending on context.
  - `--widevine.key=<KID>:<Key>` – include Widevine-specific PSSH metadata. Similarly, `--playready.key=<KID>:<Key>` or `--playready.la_url=<LicenseURL>` for PlayReady, and `--fairplay.key_file=<PATH>` or `--encrypt_key_url=<URL>` for FairPlay HLS keys, etc. There are corresponding options to specify DRM metadata like Widevine PSSH (`--widevine.drm_specific_data`) or FairPlay IV and key URI.
  - `--iss.key=<KID>:<Key>` – this refers to PlayReady (ISS = IIS Smooth Streaming) key, often used in Smooth or CMAF context for PlayReady DRM ([Packaging for MPEG-DASH — Unified Streaming](https://docs.unified-streaming.com/documentation/package/mpeg-dash.html#creating-the-media-presentation-description-file-mpd#:~:text=mp4split%20,128k.mp4)).
  - You can use multiple DRM options together if packaging for multi-DRM. For example, a single `mp4split` command can embed both Widevine and PlayReady info in a CMAF file by providing both sets of options ([Packaging for MPEG-DASH — Unified Streaming](https://docs.unified-streaming.com/documentation/package/mpeg-dash.html#creating-the-media-presentation-description-file-mpd#:~:text=mp4split%20,128k.mp4)).
  - `--encrypt_cpix=<file.xml>` – instead of specifying keys on the command line, you can provide a CPIX XML file that contains keys and DRM signaling. `mp4split` will read the keys from there and apply them. (There's also `--decrypt_cpix` for decrypting with a CPIX file, see below.)

  If you are encrypting, the output segments will be encrypted and the manifest will contain DRM signaling (e.g., `<ContentProtection>` in MPD or `#EXT-X-KEY` in HLS). For testing encryption, you can use clear keys or dummy DRM parameters, but for production you'd integrate with a license server (via the provided LA_URL or PSSH data).

- **On-the-fly Decryption:** In addition to encryption, `mp4split` can *decrypt* media if you supply the keys. For example, if you have an MP4 encrypted with CENC, you can do:

```bash
  mp4split -o decrypted.mp4 --key=<KID>:<Key> encrypted_input.mp4
```

  to decrypt it (outputting a clear MP4) ([Program Usage — Unified Streaming](https://docs.unified-streaming.com/documentation/package/usage.html#:~:text=match%20at%20L619%20mp4split%20,key%3DKID%3ACEK%20encrypted.mp4)). If multiple keys are used or the encryption info is in CPIX, you can use `--decrypt_cpix=keys.cpix` to let the tool handle the decryption ([Program Usage — Unified Streaming](https://docs.unified-streaming.com/documentation/package/usage.html#:~:text=match%20at%20L631%20mp4split%20,decrypt_cpix%3Dfilename.cpix%20encrypted.mp4)). This is useful if you need to repackage content that's already encrypted (you might decrypt and then re-encrypt in a different scheme in one go).

- **AWS S3 and Cloud Inputs/Outputs:** `mp4split` supports reading from or writing to cloud storage by piping data. For instance, you can stream output to AWS S3 by using `-o stdout:... | aws s3 cp - s3://bucket/...` or provide S3 credentials via `--s3_access_key`, `--s3_secret_key`, etc., so that `mp4split` can fetch/provide content directly ([Program Usage — Unified Streaming](https://docs.unified-streaming.com/documentation/package/usage.html#:~:text=You%20can%20instruct%20,s3_region)). In practice, a simpler way is often to run `mp4split` locally and then upload, but the tool gives flexibility for certain workflows (see **Using Cloud Storage** in docs).

- **Return Codes and Logging:** `mp4split` will return a non-zero exit code if packaging fails (and try to print an error to stderr). The docs enumerate specific status codes for error conditions ([Unified Packager — Unified Streaming](https://docs.unified-streaming.com/documentation/package/index.html#:~:text=,Status%20codes)) (for example, code for license errors, file not found, etc.). If an error occurs, you can run with increased verbosity (there isn't a specific `-v` flag, but errors are usually descriptive). Always check the console output for warnings – e.g., if a source MP4 has non-compliant features, `mp4split` might still succeed but warn about them.

In summary, the `mp4split` CLI is quite flexible. You can use it to **repack media into various streaming formats**, **filter or combine tracks**, **encrypt for DRM**, and **generate manifests/playlists**. Below, in Advanced Features, we discuss some of these use cases (multi-bitrate, subtitles, etc.) in more detail, and in the Examples section, we walk through concrete command examples.

## Advanced Features

### DRM Support

One of Unified Packager's core strengths is its comprehensive DRM support. It can encrypt content and produce outputs compatible with all major DRM systems – including **Google Widevine**, **Microsoft PlayReady**, **Apple FairPlay**, and even Marlin ([Unified Packager — Unified Streaming](https://docs.unified-streaming.com/documentation/package/index.html#:~:text=,4%2C%20DTS%3AX)). During packaging, you can apply **Common Encryption (CENC)** for DASH (which covers Widevine and PlayReady by embedding the appropriate metadata) and **AES-128/SAMPLE-AES/CBCS** for HLS (for FairPlay or clear-key HLS).

- **Common Encryption (DASH and CMAF):** The tool supports both CENC (CTR mode) and CBCS schemes. You provide one or more keys (and key IDs) via CLI or CPIX, and `mp4split` will encrypt the fragments and insert DRM metadata. For Widevine, it generates a PSSH box with Widevine DRM info; for PlayReady, it can include the PlayReady Object (or set an LA_URL for license acquisition) ([Packaging for MPEG-DASH — Unified Streaming](https://docs.unified-streaming.com/documentation/package/mpeg-dash.html#creating-the-media-presentation-description-file-mpd#:~:text=mp4split%20,128k.mp4)). You can include multiple DRM signals in one go. For example, you might specify both `--widevine.key` and `--playready.key` options for the same output, and the CMAF fragments will contain both Widevine PSSH and PlayReady headers so that either DRM can license the content ([Packaging for MPEG-DASH — Unified Streaming](https://docs.unified-streaming.com/documentation/package/mpeg-dash.html#creating-the-media-presentation-description-file-mpd#:~:text=mp4split%20,128k.mp4)). This **multi-DRM packaging** means you don't need to produce separate files for each DRM – one set of segments can serve all, which simplifies workflows.
- **Apple FairPlay (HLS):** For HLS, FairPlay uses CBCS encryption in fragmented MP4 or SAMPLE-AES in TS. `mp4split` supports FairPlay by allowing you to specify a key and IV (or a key file) and the `com.apple.streamingkeydelivery` key format. It will produce HLS playlists (`.m3u8`) with the appropriate `#EXT-X-KEY` tags pointing to your license (key) server and indicating the encryption method ([Packaging HTTP Live Streaming with fragmented MP4 (fMP4 HLS) — Unified Streaming](https://docs.unified-streaming.com/documentation/package/fmp4-hls.html#overview-of-steps-involved-in-packaging-fmp4-hls#:~:text=mp4split%20,cbcs.cmfa)). For example, using `--encrypt_key_url=<skd://...>` and `--key_format="com.apple.streamingkeydelivery"` will mark the playlist for FairPlay keys ([Packaging HTTP Live Streaming with fragmented MP4 (fMP4 HLS) — Unified Streaming](https://docs.unified-streaming.com/documentation/package/fmp4-hls.html#overview-of-steps-involved-in-packaging-fmp4-hls#:~:text=mp4split%20,cbcs.cmfa)).
- **Multi-key and Key Rotation:** Unified Packager can handle multiple keys, for instance encrypting different audio and video tracks with distinct keys, or rotating keys across segments. This is accomplished by providing multiple `--cenc.key` (or scheme-specific keys) with different KIDs or by using a CPIX file that defines key periods. The packaging process will then encrypt different portions of the content with different keys. All major DRM systems are supported in this multi-key scenario as well ([Unified Packager — Unified Streaming](https://docs.unified-streaming.com/documentation/package/index.html#:~:text=subtitle%20and%20video%20formats%2C%20and,add%20accessibility%20options)), and the output manifest (MPD) will list all key IDs for the content. This allows robust content protection strategies like periodic key rotation without extra packaging steps.
- **DRM Metadata and Signaling:** `mp4split` ensures that all necessary DRM signaling is present in the outputs. For DASH, it adds `<ContentProtection>` elements in the MPD for each DRM (Widevine, PlayReady, etc.) including the necessary PSSH or license server URL if provided ([Packaging for MPEG-DASH — Unified Streaming](https://docs.unified-streaming.com/documentation/package/mpeg-dash.html#creating-the-media-presentation-description-file-mpd#:~:text=mp4split%20,128k.mp4)). For HLS, it inserts `EXT-X-KEY` tags in the media playlists with the correct KEYFORMAT and URI for FairPlay or with the identity for AES-128 keys. This means once packaging is done, the content is ready to be licensed by the respective DRM license servers with no further manual editing of manifests.

Overall, the Unified Packager allows you to prepare one set of media files that can be played under multiple DRM systems. This greatly simplifies multi-platform distribution (for example, the same CMAF files can be used for Widevine on Android, PlayReady on Windows, and FairPlay on iOS). In practice, you will generate or obtain keys from your DRM provider, then run `mp4split` with those keys (or a CPIX) to encrypt during packaging. The result is **encrypted media segments** and **manifests with DRM info** – ready to upload to your CDN or origin. (For development and testing, you can also use sample keys and test players. The `--show-license` option of `mp4split` can show if your license enables certain DRM features if you need to verify licensing ([License Key — Unified Streaming](https://docs.unified-streaming.com/installation/license.html#:~:text=Features%20and%20Expiry%20%2011)).)

### Subtitles and Closed Captions

Unified Packager includes robust support for subtitles and captions, ensuring that text-based media can be integrated into your streams:

- **Subtitle Format Conversion:** The tool can easily convert common subtitle formats. For example, you might have subtitles in **SRT** (SubRip) or **WebVTT** format – `mp4split` can ingest these and output **TTML** (XML) or **WebVTT**, or even package them into fragmented MP4 tracks. The documentation highlights that WebVTT, SRT, TTML (IMSC1), and CEA-608 closed captions are supported ([Unified Packager — Unified Streaming](https://docs.unified-streaming.com/documentation/package/index.html#:~:text=,608)). In practice, if you provide a `.srt` file as an input and specify an MP4 output (`.cmft` for a CMAF text track, or `.ismt` for a Smooth text track), `mp4split` will convert the subtitle into a segmented MP4 track. For example: `mp4split -o subs-en.cmft subtitles.en.srt --track_language=eng` takes an English SRT and produces `subs-en.cmft` (CMAF Text track) ([Packaging for MPEG-DASH — Unified Streaming](https://docs.unified-streaming.com/documentation/package/mpeg-dash.html#creating-the-media-presentation-description-file-mpd#:~:text=mp4split%20,track_language%3Deng)). This `.cmft` can then be included in a DASH or HLS stream as a subtitle track.
- **Embedding and Extracting Captions:** If your source MP4 has embedded closed captions (e.g., CEA-608/708 data in the video stream), the packager can extract those into a separate track or file. Conversely, it can inject subtitle tracks into the output streams. For HLS, one common approach is to produce WebVTT sidecar files for captions. `mp4split` can generate WebVTT from TTML or vice versa using appropriate options (the docs provide specific conversion workflows, like converting an MP4 with embedded captions to a TTML or WebVTT file ([Unified Packager — Unified Streaming](https://docs.unified-streaming.com/documentation/package/index.html#:~:text=,to%20TTML%20or%20WebVTT))).
- **Multiple Subtitle Tracks and Languages:** You can package multiple subtitle languages in one go. For DASH, you'd create a `.cmft` (or `.ismt`) for each language and then list them all when generating the MPD. The MPD will contain `<AdaptationSet>` entries for each language (with roles like subtitle or caption). For HLS, you can produce multiple WebVTT files and then use HLS master playlist tags (`EXT-X-MEDIA` for TYPE=SUBTITLE) to link them. `mp4split` helps in generating those media playlists as well. For example, when packaging HLS, adding an SRT as an input alongside video and audio and specifying output `.m3u8` can result in a subtitle rendition playlist.
- **Subtitle Delivery Formats:** The packager supports both in-band and out-of-band subtitle delivery. In CMAF/DASH, typically subtitles are delivered as fragmented MP4 (MP4 with text tracks) or as separate WebVTT files referenced in the MPD. In HLS, subtitles can be WebVTT in separate files referenced by the master playlist, or muxed in TS segments as 608/708 (though Apple recommends WebVTT for modern HLS). Unified Packager makes it easy to get the right format: e.g., it can produce an **.ismt** file (Smooth Streaming text track MP4) or a **.vtt** file depending on what you need. The **Supported formats for subtitles** list in the documentation confirms these capabilities ([Unified Packager — Unified Streaming](https://docs.unified-streaming.com/documentation/package/index.html#:~:text=,to%20TTML%20or%20WebVTT)).
- **Example:** A common use-case is taking a TTML subtitles file (perhaps from a broadcaster) and creating WebVTT for HLS. The packager can do: `mp4split -o captions.vtt subtitles.ttml` to quickly convert TTML to WebVTT ([Unified Packager — Unified Streaming](https://docs.unified-streaming.com/documentation/package/index.html#:~:text=,to%20TTML%20or%20WebVTT)). Conversely, `mp4split -o captions.ttml subtitles.vtt` would go the other way. This saves time by automating conversions instead of doing them manually or with separate tools.

In summary, you can rely on `mp4split` to **integrate subtitles/captions** into your streaming outputs, whether by embedding them in media segments or generating separate subtitle files. This is crucial for accessibility (closed captions for the hearing impaired) and multi-language support, and the packager's ability to convert between formats means you can take whatever subtitle source you have and output the format required by your target players.

### Multi-bitrate Encoding & Adaptive Streaming

Adaptive streaming (ABR) is at the heart of modern video delivery, and Unified Packager is built to facilitate packaging of multiple bitrate renditions of the same content. To use `mp4split` for ABR:

- **Preparing Multiple Renditions:** First, you need to have your content encoded at multiple bitrates and/or resolutions (e.g., 1080p @ 5Mbps, 720p @ 2Mbps, 480p @ 1Mbps, etc., plus audio). The packager does *not* encode video – it assumes you already have the encodings. Typically, each rendition is an MP4 file.
- **Packaging Each Rendition:** You then run `mp4split` on each file to create segmented output. For DASH/CMAF, that means producing `.cmfv` files for video and `.cmfa` for audio (or multiplexed `.mp4` segments for older Smooth/HDS). For HLS, that means producing either a set of `.ts` segments and a playlist or `.m4s` segments (fMP4) and a playlist for each rendition. After this step, each rendition has its own set of segments and a playlist/manifest describing just that rendition.
- **Generating Master Manifests:** The final step is to create a master manifest that brings all renditions together for the player. In MPEG-DASH, this is the MPD file that contains multiple `<Representation>` entries (within AdaptationSets) for the various bitrates. In HLS, this is the Master playlist `.m3u8` that uses `EXT-X-STREAM-INF` to list each variant. `mp4split` can automate the creation of these master manifests:
  - For **DASH**, use the `--package_mpd` mode and list all the track files. For example: `mp4split --package_mpd -o master.mpd video_5000k.cmfv video_2000k.cmfv audio.cmfa` will produce an MPD with two video representations (5000k and 2000k) and one audio, assuming each input is the fragmented output of a prior step ([Packaging for MPEG-DASH — Unified Streaming](https://docs.unified-streaming.com/documentation/package/mpeg-dash.html#creating-the-media-presentation-description-file-mpd#:~:text=mp4split%20,dash.cmfv)). The packager handles aligning them in the MPD. It's crucial that all renditions have aligned segment boundaries (which they will if encoded from the same source with consistent keyframe interval). The MPD will include each bitrate's details (bandwidth, resolution) automatically, or you can override attributes if needed (there are options like `--mpd.average_bitrate` etc. for fine control).
  - For **HLS**, you can similarly create a master playlist by providing the individual variant playlists as inputs. For instance: `mp4split --package_hls -o master.m3u8 \
    1080p/prog_index.m3u8 720p/prog_index.m3u8` takes two pre-generated HLS playlists and combines them into one master `master.m3u8` ([Packaging HTTP Live Streaming (HLS) with TS — Unified Streaming](https://docs.unified-streaming.com/documentation/package/hls.html#advanced-recipes#:~:text=mp4split%20,presentation_s2%2Fprog_index.m3u8)). The resulting master playlist will have entries for both renditions. The packager reads the bandwidth (EXT-X-TARGETDURATION, etc.) from each playlist to populate the master's `EXT-X-STREAM-INF` lines. Alternatively, you can use `--variant_set` options during packaging to create a master in one go, but the two-step approach (generate each, then combine) is often simpler.

- **Alignment and Segmenting:** The packager itself does not transcode, so it relies on the input files having GOP alignment for smooth switching. However, it does offer options to ensure consistent fragment durations across renditions. For example, you can specify `--fragment_duration=<time>` when packaging each rendition to cut segments at exact intervals (e.g., every 2 seconds or every 6 fragments per second). If all renditions use the same fragment duration or keyframe interval, their segment boundaries will line up, which is required for ABR. Tools like Unified Packager's recommendations suggest using a timescale that's a multiple of framerate and setting a uniform fragment length ([General Recommendations — Unified Streaming](https://docs.unified-streaming.com/best-practice/general-origin.html#:~:text=,affects%20HLS%20TS)).
- **Audio/Subtitle Variants:** In ABR streaming, typically audio is delivered as a single track for all video variants (to avoid duplicating audio for each quality). With `mp4split`, you might package your audio once (say a stereo track at 128kbps) and use it for all variants. The master playlist or MPD will then signal that each video representation should play with the common audio. This is achieved by how you build the manifest: for DASH, video and audio are separate AdaptationSets (players combine them); for HLS, the master playlist will include an AUDIO group for the audio track and each variant stream will reference that group. The packager can handle that via naming conventions or the `--variant_set`/`--audio_group` parameters, but an easier method is as described: generate audio playlist and video playlists, then combine appropriately.
- **Multi-Variant HLS Packaging:** Unified Packager provides convenience flags like `--variant_set` to group outputs. For example, if you package multiple HLS renditions in one command using `--variant_set` with the same name, it will produce a master playlist grouping them ([General Recommendations — Unified Streaming](https://docs.unified-streaming.com/best-practice/general-origin.html#:~:text=%2A%20Should%20Fix%3A%20Use%20,affects%20DASH%20only)). Also, by default it will try to order variants by bitrate (you can control order or naming if needed). There are options to automatically add audio-only variants or I-frame only playlists. For instance, `--create_iframe_playlist` can generate an HLS playlist containing only I-frame segments for trick-play (which some players use for scrubbing thumbnails) ([Packaging HTTP Live Streaming with fragmented MP4 (fMP4 HLS) — Unified Streaming](https://docs.unified-streaming.com/documentation/package/fmp4-hls.html#overview-of-steps-involved-in-packaging-fmp4-hls#:~:text=match%20at%20L595%20mp4split%20,fmp4.m3u8)). This is an advanced use case but highlights the tool's ability to generate additional variant streams beyond the primary video/audio.

In essence, **to achieve adaptive streaming**, you will run `mp4split` for each rendition and then use it to assemble a master manifest. The tool ensures that all those outputs are compatible with each other and follow the HLS/DASH specifications for variant playlists. The result is that clients can seamlessly switch between bitrates based on network conditions. By following best practices (aligned segments, correct manifest parameters), Unified Packager helps you create highly interoperable ABR content. Testing with Apple's *MediaStreamValidator* (for HLS) and the DASH-IF Conformance Tool (for DASH) is recommended (see Troubleshooting) to double-check everything is set for smooth playback.

### Live to VOD Workflows

In addition to on-demand packaging, `mp4split` can assist in **Live-to-VOD and VOD-to-Live** scenarios:

- **Converting Live fragments to VOD:** If you have content that was recorded or generated as fragmented streams (for example, a live stream archive saved as `.ismv` segments or CMAF chunks), you can use Unified Packager to convert it back into a regular MP4 for VOD viewing. The documentation explicitly notes that packaging can go "MP4 to fragmented MP4 **and back**" ([Packaging for Unified Origin — Unified Streaming](https://docs.unified-streaming.com/documentation/package/package.html#package-mp4-to-fragmented-mp4-and-back#:~:text=mp4split%20)). For instance, given a Smooth Streaming fragmented file `video.ismv`, you can do `mp4split -o video.mp4 video.ismv` to stitch the fragments back into a continuous MP4 ([Packaging for Unified Origin — Unified Streaming](https://docs.unified-streaming.com/documentation/package/package.html#package-mp4-to-fragmented-mp4-and-back#:~:text=mp4split%20)). Similarly, an HDS `.f4f` fragment file or even an entire Smooth `.ism` manifest can be input, and `mp4split` will produce a single MP4. This is useful for taking a live DVR archive and turning it into a downloadable or seekable MP4 asset once the live event is over.
- **Using Server Manifests as Input:** You can feed a Smooth Streaming manifest (`.ism`) or HDS manifest (`.f4m`) into `mp4split` as an input, and it will locate all the referenced segment files and combine them. For example, `mp4split -o combined.mp4 stream.ism` will read all video/audio tracks from `stream.ism` (and associated `.ismv/.isma` files) and output one MP4 ([Packaging for Unified Origin — Unified Streaming](https://docs.unified-streaming.com/documentation/package/package.html#package-mp4-to-fragmented-mp4-and-back#:~:text=You%20can%20also%20use%20the,All%20the%20audio%20and%20video)). This simplifies consolidation of a segmented live stream. Essentially, the packager can act as a *demuxer* for the live packages.
- **Packaging Live streams for catch-up:** In some workflows, after a live stream ends, you might want to package the content for on-demand replay (possibly with different segment durations or with DRM). `mp4split` can take the recorded file from a live encoder (e.g., a large TS file or MP4) and package it just like any VOD asset. There's nothing fundamentally different in usage – you'd just ensure your input is the full recorded file and then produce HLS/DASH outputs. If the live encoder produced segments already, you could use the method above to merge to one file and then re-package. The packager's speed (it's quite fast since it's not encoding) allows quickly turning around a live broadcast into VOD assets.
- **VOD to Live (Looping content):** While `mp4split` itself is for static packaging, Unified Streaming also offers a tool called Unified Remix and a concept of VOD2Live (turning VOD assets into a live stream). That is outside the scope of `mp4split` usage directly (Unified Remix or Unified Origin would handle dynamic looping). However, `mp4split` could prepare the VOD assets (e.g., properly fragmented files) which then a live origin could stream in a loop. If doing a 24/7 loop channel from files, you'd ensure all files are packaged in a consistent way (same codecs, resolutions) with `mp4split` beforehand.

In summary, **Live-to-VOD**: You can feed live format files into `mp4split` to generate MP4s, or feed MP4s to `mp4split` to generate on-demand HLS/DASH for catch-up. This covers use cases like archiving a live event for later playback. Because `mp4split` can output both ways, it provides flexibility in transitioning between live and on-demand content. For example, after a live streaming event, you might end up with a set of CMAF segments and a DASH MPD; you could run `mp4split` to produce a single MP4 for that event which you then offer as a file download or re-package with different parameters. Conversely, you could take a large file (say a raw recording) and quickly generate a segmented catch-up asset with `mp4split` to make it available on your platform with minimal delay.

### Packaging Different Formats

Unified Packager (`mp4split`) supports a variety of output formats, each with its own file conventions and options. Here's a quick overview of how it handles each and what outputs to expect:

- **MPEG-DASH (ISO BMFF CMAF):** For DASH, `mp4split` produces fragmented MP4 files (often CMAF compliant) for each stream and an MPD manifest. Video fragments typically have extension `.cmfv` (or `.m4s`), audio `.cmfa`, and text `.cmft`, though extensions can vary. You use `--package_mpd` to create the MPD ([Packaging for MPEG-DASH — Unified Streaming](https://docs.unified-streaming.com/documentation/package/mpeg-dash.html#creating-the-media-presentation-description-file-mpd#:~:text=mp4split%20,dash.cmfv)) after generating the fragments. DASH outputs can be tailored to profiles – e.g., you can specify `--mpd.profile=urn:mpeg:dash:profile:isoff-on-demand:2011` or use default live profile. The MPD will include timing, segment templates or lists, etc., according to how you packaged (explicit segment files vs using internal indexing).
- **Apple HLS (TS segments):** For traditional HLS with MPEG-TS segments, `mp4split` will produce `.ts` files and a `.m3u8` playlist. You may specify HLS version parameters (for example, HLS version 3 for older devices using TS). By default, HLS TS packaging will create a media playlist named `prog_index.m3u8` (or one you name) and segment files typically named after the base media file with a sequence number. There are many HLS-specific options like `--hls.segment_duration`, `--hls.client_manifest_version` (to force a certain HLS playlist version), and `--hls.no_multiplex` (to produce separate audio/video TS tracks rather than a single multiplexed TS – recommended for modern ABR) ([General Recommendations — Unified Streaming](https://docs.unified-streaming.com/best-practice/general-origin.html#:~:text=%2A%20Should%20Fix%3A%20Set%20,affects%20Smooth%20only)). The HLS playlists will contain `EXT-X-TARGETDURATION`, `EXTINF`, etc., as appropriate. You can also generate an **I-frame only playlist** (for trick play) using `--create_iframe_playlist` in a separate `mp4split` run ([Packaging HTTP Live Streaming with fragmented MP4 (fMP4 HLS) — Unified Streaming](https://docs.unified-streaming.com/documentation/package/fmp4-hls.html#overview-of-steps-involved-in-packaging-fmp4-hls#:~:text=mp4split%20,fmp4.m3u8)).
- **Apple HLS (fMP4/CMAF segments):** HLS also supports fMP4 segments (CMAF chunks) typically with HLS version 7 or later. `mp4split` can produce HLS fMP4 by fragmenting the media into `.m4s` (or `.cmfv/.cmfa`) and then generating `.m3u8` playlists that reference those segments. It will include `#EXT-X-MAP` in the playlist to signal the init fragment (if using CMAF). Encryption for these (FairPlay) uses CBCS and is signaled in the playlist. One advantage of CMAF is that the same fragmented files can be used for both HLS and DASH; you might run `mp4split` once to make `.cmfv`/`.cmfa` and then create both an MPD and an HLS master playlist from them ([Unified Packager — Unified Streaming](https://docs.unified-streaming.com/documentation/package/index.html#:~:text=%2A%20Multi,Testing%20playback)) ([Unified Packager — Unified Streaming](https://docs.unified-streaming.com/documentation/package/index.html#:~:text=,Testing%20playback)). The Unified Packager documentation specifically highlights the **convergence of HLS and DASH via CMAF** – you can have a unified media container and just different manifests for each protocol.
- **Microsoft Smooth Streaming (HSS/MSS):** Smooth Streaming output consists of a server manifest `.ism` (XML) and client manifest `.ismc` (optional), plus segmented files with extensions `.ismv` (video fragments) and `.isma` (audio fragments). Using `mp4split`, you typically create the `.ismv/.isma` by fragmenting the MP4 and then generate an `.ism`. For example: `mp4split -o video.ismv input.mp4 --track_type=video` and similarly for audio, then `mp4split -o stream.ism video.ismv audio.ismv`. The `.ism` serves a similar role to an HLS master or DASH MPD (it indexes the tracks and fragments). `mp4split` can also produce a combined `.ism` and `.ismv` in one step if given a multiplexed input. Smooth also allows encryption via PlayReady "PIFF" which `mp4split` supports (using the `--iss.key` and related options for PlayReady encryption).
- **Adobe HDS:** Adobe's HTTP Dynamic Streaming (legacy Flash streaming) uses `.f4f` fragment files and a manifest `.f4m`. With `mp4split`, you can package HDS by using `--hds` options. It will output `.f4x` index files along with `.f4f` segments and an `.f4m` manifest. Although HDS is legacy, if needed, the packager can produce it (and even encrypt with Adobe Access DRM if given the parameters). The usage is less common, so refer to docs if needed (there's a section on HDS packaging ([Unified Packager — Unified Streaming](https://docs.unified-streaming.com/documentation/package/index.html#:~:text=,475))).
- **Unified Origin format:** This refers to preparing content for Unified Streaming's own origin server in a static way. Essentially, it means fragmenting to `.ismv/.isma` and possibly generating an `.ism` file, which the Unified Origin module can then use to serve HLS/DASH dynamically. The packager provides options to **override or add track properties** (like language, codecs, bitrate in the `.ism` file) for use by the origin server ([Packaging for Unified Origin — Unified Streaming](https://docs.unified-streaming.com/documentation/package/package.html#package-mp4-to-fragmented-mp4-and-back#:~:text=mp4split%20,track_bitrate%3D400000)). If you're using Unified Origin, the recommended practice is to use `mp4split` to create the fragmented files and then let the origin do the manifesting. There are specific options like `--fragment_duration` and `--timeshift_depth` that matter in live origin scenarios.
- **Other Formats and Features:** The packager also supports generating content for **HbbTV** (which is essentially DASH or HLS with specific requirements) and **DVB-DASH** profiles. It has built-in support for codec-specific packaging considerations, like signaling for Dolby Vision in DASH (there's an "Dolby Vision Support" section ([Unified Packager — Unified Streaming](https://docs.unified-streaming.com/documentation/package/index.html#:~:text=,Advanced%20recipes)) in docs) and for audio channel layout signaling in HLS. If you have trick-play video (keyframe-only tracks or thumbnail tracks), there are features to package those and insert them into manifests as well ([Unified Packager — Unified Streaming](https://docs.unified-streaming.com/documentation/package/index.html#:~:text=,TTML%20or%20WebVTT)).

In practice, you will invoke `mp4split` with certain combinations of options depending on the output format. The **good news** is that the tool centralizes all these in one binary, so you learn one syntax and then just adjust options per format. For example:
- To package for **DASH and HLS from the same source** (CMAF): package to `.cmfv/.cmfa` segments, then run `--package_mpd` for MPD and `--package_hls` for M3U8. The heavy lifting (fragmenting and encrypting) only needs to be done once.
- To package for **HLS (TS)**: perhaps run `mp4split --package_hls` on each bitrate MP4 to get `.ts` segments and .m3u8, then combine master. If encryption is needed (AES-128 or SAMPLE-AES), include those options and the playlist will have the proper tags.
- To package for **Smooth**: run `mp4split` to get .ismv/.isma and .ism (the `.ism` can be used by Smooth clients or by Unified Origin to then proxy as DASH/HLS).

All of these formats are supported within the same tool ([Unified Packager — Unified Streaming](https://docs.unified-streaming.com/documentation/package/index.html#:~:text=Key%20features)), making Unified Packager a one-stop solution for creating a multi-format content library.

## Performance Optimization & Troubleshooting

Packaging with `mp4split` is generally straightforward, but there are best practices to optimize performance and quality, as well as strategies to troubleshoot issues when they arise.

### Performance Optimization & Best Practices

To ensure efficient packaging and optimal playback performance of the packaged media, consider the following:

- **Fragment Duration and Alignment:** Choose an appropriate segment duration and ensure alignment across renditions. Smaller segments yield lower latency but cause more overhead (more HTTP requests), whereas longer segments improve throughput but increase latency. A common sweet spot for VOD is 4-6 seconds per segment. You can control fragment duration with `--fragment_duration` (in terms of timescale units) or `--[hls|mpd].minimum_fragment_length`. It's recommended to set a uniform fragment length for all outputs and keyframes, so that segment boundaries align ([General Recommendations — Unified Streaming](https://docs.unified-streaming.com/best-practice/general-origin.html#:~:text=,affects%20HLS%20TS)). Also use a timescale that is a multiple of the frame rate to avoid timing precision issues (e.g., 90000 or 48000). The docs suggest ensuring the timescale divides evenly by the frame rate ([General Recommendations — Unified Streaming](https://docs.unified-streaming.com/best-practice/general-origin.html#:~:text=,affects%20HLS%20TS)) – this prevents cumulative timing errors in segment durations.
- **No Audio/Video Multiplexing (for HLS TS):** If you're packaging HLS in TS format, by default older versions would interleave audio & video in one .ts. However, Apple recommends splitting audio and video into separate TS streams for better adaptability. Use `--hls.no_multiplex` to create separate audio-only and video-only variant streams ([General Recommendations — Unified Streaming](https://docs.unified-streaming.com/best-practice/general-origin.html#:~:text=%2A%20Should%20Fix%3A%20Set%20,affects%20Smooth%20only)). This can improve ABR switching performance and reduce duplicate audio across variants. Similarly, specify `--hls.client_manifest_version 4` or above to indicate to players that audio/video are separate (version 4 of HLS introduced that) ([General Recommendations — Unified Streaming](https://docs.unified-streaming.com/best-practice/general-origin.html#:~:text=%2A%20Should%20Fix%3A%20Set%20,affects%20Smooth%20only)).
- **Inline Parameter Sets (for H264/H265):** Ensure your encoders produced CMAF compliant files (for fMP4) or have parameter sets (SPS/PPS) in-band for HLS TS if needed. While not a setting in `mp4split` itself, this is a content preparation tip: having keyframes aligned and parameter sets in each segment's first GOP helps independent decoding.
- **Use Multiple Cores/Parallelism:** `mp4split` is single-job oriented (it processes one packaging job per invocation). If you have many renditions to package, run multiple instances in parallel to utilize multiple CPU cores. Packaging is mostly I/O-bound (reading and writing files) but can also use CPU when doing encryption. Running, say, 4 parallel `mp4split` processes on a 4-core machine (each handling a different rendition or piece of content) can dramatically speed up overall packaging throughput.
- **Fast Storage:** Perform packaging on fast local storage (SSD/NVMe). Since static packaging reads the entire source file and writes out segments, disk I/O is a major factor. Using local SSDs or a high-throughput storage will speed up the operation. If your source is on cloud storage, consider downloading it first, or use the streaming input feature of `mp4split` carefully with adequate network speed.
- **Avoid Unnecessary Repackaging:** If you plan to output both HLS and DASH from the same content, use the CMAF approach to avoid doing the work twice. Package once into CMAF fragments, then just generate two different manifests. This reuses the media segments for both, which is storage-efficient and time-efficient.
- **Storage Planning:** Note that static packaging creates separate files for each format and bitrate. This means if you have one MP4 and you package it into HLS and DASH, you will now have two sets of files on disk (plus possibly the original). Plan for the increased storage. The docs emphasize that each additional format duplicates the asset on disk ([Unified Packager — Unified Streaming](https://docs.unified-streaming.com/documentation/package/index.html#:~:text=Static%20packaging%20is%20the%20process,be%20part%20of%20the%20packaging)). To mitigate this, you can use CMAF to unify between HLS and DASH, but you'll still have at least one full copy per packaged set.
- **Content Preparation Checks:** Before packaging, ensure your source content is well-formed. Run basic checks on the MP4 (for example, use `mp4info` or `ffprobe` to verify there are no irregularities like variable frame rate or missing parameters). `mp4split` relies on proper timing in the source; if an MP4 has a weird edit list or non-monotonic timestamps, consider re-muxing it with a tool like ffmpeg before packaging.
- **Leveraging Best Practices from Docs:** Unified Streaming provides a "Best Practice" guide ([General Recommendations — Unified Streaming](https://docs.unified-streaming.com/best-practice/general-origin.html#:~:text=,affects%20HLS%20TS)) ([General Recommendations — Unified Streaming](https://docs.unified-streaming.com/best-practice/general-origin.html#:~:text=%2A%20Should%20Fix%3A%20Enable%20,when%20streaming%20DRM%20protected%20content)). They suggest things like enabling `--mpd.inline_drm` (to include DRM info in MPD rather than require separate license requests) for DASH ([General Recommendations — Unified Streaming](https://docs.unified-streaming.com/best-practice/general-origin.html#:~:text=%2A%20Should%20Fix%3A%20Enable%20,especially%20when%20streaming%20DRM)), using `--mpd.segment_template=time` for certain low-latency uses ([General Recommendations — Unified Streaming](https://docs.unified-streaming.com/best-practice/general-origin.html#:~:text=%2A%20Should%20Fix%3A%20Enable%20,affects%20DASH%20only)), and ensuring HTTPS delivery for DRM content ([General Recommendations — Unified Streaming](https://docs.unified-streaming.com/best-practice/general-origin.html#:~:text=%2A%20Should%20Fix%3A%20Set%20,58)). While some of these don't affect packaging performance per se, they do affect playback performance and compatibility (e.g., HTTPS is required by browsers for EME playback of DRM). As another example, enabling GZIP compression on text manifests can significantly reduce load times for clients (this is a server config, but noted in best practices).
- **Monitor Resource Usage:** If you are packaging very large files or doing batch packaging, monitor CPU, memory, and disk. `mp4split` is quite memory-efficient (it processes streams in chunks), but encryption may use more CPU. If you see bottlenecks, adjust accordingly – e.g., if CPU is pegged but disk is idle, parallelize tasks; if disk I/O is saturated, consider faster storage or spreading work across drives.

In summary, packaging is typically fast (much faster than encoding), but you can optimize by aligning content and using the tool's options wisely. Following the recommended settings from the documentation will lead to more *efficient packaging and smoother streaming*. Always validate the output – a properly packaged stream should produce no errors in validators and should play back with minimal startup delay and smooth switches.

### Troubleshooting & Debugging

When issues arise, the following tips can help diagnose and resolve common problems with packaged streams:

- **License Key Issues:** If `mp4split` isn't working or the output streams won't play on Unified Origin, ensure the license is correctly installed. A tell-tale sign is an error about the license. For example, in an Origin setup, an error log "**failed to initialize! (Invalid base64 character)**" indicates the license key wasn't read properly ([Troubleshooting VOD Streaming — Unified Streaming](https://docs.unified-streaming.com/documentation/vod/troubleshooting.html#:~:text=This%20error%20typically%20indicates%20that,looking%20for%20the%20following%20error)). In CLI use, if the license is missing or invalid, `mp4split` may refuse to run or produce content that triggers a license error. Double-check that the `UspLicenseKey` env variable is set with no typos or newline issues (common if copy-pasting the key) ([Troubleshooting VOD Streaming — Unified Streaming](https://docs.unified-streaming.com/documentation/vod/troubleshooting.html#:~:text=This%20error%20typically%20indicates%20that,looking%20for%20the%20following%20error)). You can run `mp4split --show-license` to see if the tool recognizes your key and what features are enabled ([License Key — Unified Streaming](https://docs.unified-streaming.com/installation/license.html#:~:text=Features%20and%20Expiry%20%2011)).
- **Playback Stops Immediately:** If you packaged content and find that on some players the video stops right away or fails to start, inspect the files. One known issue involves the duration in the MP4 fragment metadata. The docs mention that for fragmented MP4 (`.ismv`), certain players might misbehave if the `moov.trak.tkhd` duration is 0 (which actually is correct per spec for streaming) ([Troubleshooting VOD Streaming — Unified Streaming](https://docs.unified-streaming.com/documentation/vod/troubleshooting.html#:~:text=Playback%20stops%20right%20after%20it,starts%20%20436)). Most modern players handle it, but older ones might not. If targeting such a player, you might need to use a workaround (such as using `--iso_live` mode off, or re-muxing final output with duration set). Generally, this is rare. More commonly, playback issues could be due to incompatible encoding (e.g., trying to play HEVC on a device that doesn't support it) – ensure your codecs and manifests signal only supported codecs for the target platform.
- **Verify Player Compatibility:** Make sure you used the right packaging settings for the target. For example, if you use fMP4 for HLS, remember that older Apple devices (pre-iOS 10) only support TS segments. If your stream isn't playing on an old device, the packaging might be fine – you just need to use TS for those or update your target requirements. Similarly, if you use features like Dolby Vision, ensure the device/player expects the enhanced layers.
- **Use Validation Tools:** Run your packaged outputs through validators:
  - For **HLS**, Apple provides **MediaStreamValidator**. Using it on your `.m3u8` can catch issues like inconsistent segment durations, missing segments, sequence gaps, ID3 timing issues, etc. It's strongly recommended to validate HLS streams with this tool ([Content Preparation — Unified Streaming](https://docs.unified-streaming.com/best-practice/content-preparation/index.html#validator-content-check#:~:text=,to%20store%20large%20content%20libraries)). If the validator reports errors, adjust your packaging parameters accordingly (e.g., sometimes you may need to include `EXT-X-VERSION` or ensure segment durations are rounded properly).
  - For **DASH**, use the **DASH-IF Conformance Tool** or the **Shaka Packager's validator** to check the MPD and segments. Unified Packager generally produces DASH that meets spec, but if you manually tweaked something (like inserted custom `EssentialProperty` or so), validation will help.
  - Also, Unified Streaming's docs suggest using `ffprobe` or similar to inspect your content if you suspect encoder issues ([Troubleshooting VOD Streaming — Unified Streaming](https://docs.unified-streaming.com/documentation/vod/troubleshooting.html#:~:text=Adaptive%20bitrate%20video%20streaming%20is,the%20overview%20in%20our%20Factsheet)). If a packaged stream isn't working, run `ffprobe` on the source MP4 to see if there were oddities (e.g., non-monotonic DTS). It might not be the packaging at fault but the source.
- **Check for Missing or Incorrect Manifest Entries:** If a particular audio or subtitle track isn't appearing in the output manifest, you may have forgotten a track option or the input did not have the track you thought. Re-run packaging with verbose output or inspect the input file with a tool to see its track IDs/languages. Then use the appropriate `--track` selection options.
- **Common Error Messages:** The documentation has a section on error messages and status codes. For instance, an error like "FMP4_403 no virtual path specified" is specific to requesting an `.ism` directly on Origin (security feature) ([Troubleshooting VOD Streaming — Unified Streaming](https://docs.unified-streaming.com/documentation/vod/troubleshooting.html#:~:text=FMP4_403%20No%20virtual%20path%20specified,434)) – not applicable to static files, but good to know if you use Origin. Another example: "origin: no policy for streaming" indicates the license isn't loaded or valid for that streaming mode ([Troubleshooting VOD Streaming — Unified Streaming](https://docs.unified-streaming.com/documentation/vod/troubleshooting.html#:~:text=FMP4_403%20origin%3A%20no%20policy%20for,streaming%20%20435)) – ensuring the license is applied fixes that.
- **Upgrade to Latest Version:** If you encounter what seems like a bug (e.g., a certain combination of features doesn't work as expected), check the release notes. The Unified Streaming team often fixes issues in new releases ([Troubleshooting VOD Streaming — Unified Streaming](https://docs.unified-streaming.com/documentation/vod/troubleshooting.html#:~:text=Release%20notes%EF%83%81)). Upgrading to the latest stable version of Unified Packager might resolve unexplained problems. Always refer to the [Release notes] for any known issues around the version you're using.
- **Network and CDN Issues:** After packaging, if you experience playback issues at scale, ensure your CDN is configured properly (e.g., MIME types for .m3u8, .mpd, CORS headers if needed for cross-domain subtitle files, etc.). These aren't packaging problems but can affect playback. For example, the player may fail to load subtitles if the server doesn't send the correct `Content-Type` for WebVTT.
- **DRM Troubleshooting:** If encrypted content isn't playing, use the player's debug logs. Often it could be a license server issue or a mismatch in key. Verify that the key IDs in the manifest match what your DRM server expects. `mp4split --show-license` will show what DRMs your license enables, just to be sure your packager isn't silently skipping adding a DRM because the license doesn't allow it (in evaluation mode, some DRM features might be limited).
- **Segment Duration Issues:** If you see a warning about the last segment being shorter or a player complains about media timeline, you might need to use `--minimum_fragment_length` to enforce a final segment length ([General Recommendations — Unified Streaming](https://docs.unified-streaming.com/best-practice/general-origin.html#:~:text=,affects%20HLS%20TS)) or adjust the source so that total duration is an exact multiple of fragment duration (or let the last segment be shorter but ensure the manifest is accurate). `mp4split` tries to handle partial final segments (it will still include them and indicate their duration).
- **Logging and Verbosity:** While `mp4split` doesn't have multiple verbosity levels, it prints informative messages. If you run it in a verbose environment, you might see all the ffmpeg plugin logging as well (for instance, if it had to use an internal decoder for some reason). Usually packaging doesn't need decoding, but if you see logs about ffmpeg, it could be doing some processing (like image thumbnail extraction or something custom). This is rare for normal usage.

By systematically validating and checking logs at each stage – input files, packaging output, and playback – you can pinpoint most issues. The key is to differentiate between packaging problems and playback environment problems. Using the reference players (e.g., Shaka Player for DASH, hls.js for HLS) can help isolate if the package itself is correct. In case of any persistent issue, Unified Streaming's knowledge base and support can be consulted, but the above practices resolve the vast majority of common issues.

### Resource Management Tips

While packaging, monitor the machine's resources:
- If you are packaging a very large library in one go, consider the disk space: packaged files can be hundreds of GBs for a feature film in multiple formats. Ensure your storage can handle it to avoid running out mid-process.
- CPU usage: Encryption (especially multi-DRM) can be CPU-intensive. If CPU is the bottleneck, try splitting tasks across machines or disabling unneeded features. For example, if you don't need a certain DRM for a test, don't include it to save overhead.
- Memory: `mp4split` is efficient, but packaging extremely high bitrate content (or long content with very few keyframes) could hypothetically use more memory. Watch the process RAM usage; it should normally be stable and modest.
- When using Docker (on Mac/Windows), allocate sufficient memory/CPU to the Docker engine to handle the packaging tasks, as container overhead might throttle performance if not configured.

Finally, always test your workflow with a short sample (e.g., a 1-minute clip) to ensure your commands produce the desired output before scaling up to full content. This helps catch misconfigurations early without wasting time on full runs.

## Examples & Tutorials

To bring together the concepts, here are some step-by-step examples of using `mp4split` in common scenarios. These examples demonstrate the commands and options in context:

**Example 1: Package multiple bitrates for HLS (VOD)**
Suppose you have two encoded MP4 files of the same video: `video_1080p.mp4` (higher bitrate) and `video_720p.mp4` (lower bitrate), and you want to create an HLS stream with those as variants.

1. **Package each rendition into HLS segments and playlist:** Use `--package_hls` to create HLS media playlists and segments for each file. For instance:

```bash
   mp4split --package_hls -o 1080p/prog_index.m3u8 video_1080p.mp4
   mp4split --package_hls -o 720p/prog_index.m3u8 video_720p.mp4
```

   This will produce two directories (`1080p` and `720p`) each containing a `prog_index.m3u8` (media playlist) and a series of `.ts` segments for the 1080p and 720p streams respectively. The option `--package_hls` signals the tool to output HLS-compliant TS segments and a playlist. By default, segments might be around ~6 seconds (depending on source duration and GOP structure, you can adjust with `--fragment_duration`). At this point, each quality level is playable on its own playlist URL.

2. **Create the HLS master playlist:** Now combine the two variant playlists into one master index so that players can switch between them:

```bash
   mp4split --package_hls -o master.m3u8 \
       1080p/prog_index.m3u8 720p/prog_index.m3u8
```

   Here we pass the previously generated playlists as inputs to `mp4split`. It will produce `master.m3u8` that contains `EXT-X-STREAM-INF` entries for both the 1080p and 720p streams ([Packaging HTTP Live Streaming (HLS) with TS — Unified Streaming](https://docs.unified-streaming.com/documentation/package/hls.html#advanced-recipes#:~:text=mp4split%20,presentation_s2%2Fprog_index.m3u8)). It reads the details from each provided playlist (bandwidth, resolution, codec info) to populate the master playlist. The master file will look something like:

```
   #EXTM3U
   #EXT-X-VERSION:4
   #EXT-X-STREAM-INF:BANDWIDTH=5000000,RESOLUTION=1920x1080,CODECS="avc1.640028,mp4a.40.2"
   1080p/prog_index.m3u8
   #EXT-X-STREAM-INF:BANDWIDTH=2000000,RESOLUTION=1280x720,CODECS="avc1.64001F,mp4a.40.2"
   720p/prog_index.m3u8
```

(plus any audio groups if present). Now your HLS packaging is complete – you would host `master.m3u8` along with the folders of segments. An HLS player can fetch the master and then the appropriate variant playlist. *Note:* We used relative paths in the master; in practice ensure the URLs are correct for your hosting environment.

3. **Test the HLS stream:** Open `master.m3u8` in an HLS compliant player (e.g., Safari or VLC, or an online tester). It should play and switch between 1080p and 720p based on bandwidth. If something is wrong (say the player only sees one rendition), check that both variant playlists were included and that their attributes (bandwidth, resolution) were properly detected. MediaStreamValidator can be run on `master.m3u8` to verify everything (it would catch issues like inconsistent segment durations or playlist syntax).

**Example 2: Package content for MPEG-DASH with encryption (CENC DRM)**
Consider you have a video file `movie.mp4` and an audio file `movie_audio.mp4` (perhaps the video was encoded to one file and audio to another, or you extracted them). You want to package them for DASH streaming, encrypting with Widevine and PlayReady DRM (common encryption). You have a Content Key (16 bytes hex) and Key ID (16 bytes hex) from your DRM system.

1. **Package video and audio to CMAF fragments with encryption:** Use `mp4split` to create encrypted segments. For example:

```bash
   mp4split -o video_enc.cmfv \
       --cenc.key=ABCDE1234567890ABCDE1234567890AB:00112233445566778899AABBCCDDEEFF \
       --widevine.drm_specific_data=<Base64PSSH> \
       movie.mp4
   mp4split -o audio_enc.cmfa \
       --cenc.key=ABCDE1234567890ABCDE1234567890AB:00112233445566778899AABBCCDDEEFF \
       movie_audio.mp4
```

   In this example, we used the same key for both video and audio for simplicity (in practice you might use different keys per track or one key for all). The `--cenc.key=<KID>:<Key>` option applies a common encryption (CENC) with that key ID and key ([Packaging for MPEG-DASH — Unified Streaming](https://docs.unified-streaming.com/documentation/package/mpeg-dash.html#creating-the-media-presentation-description-file-mpd#:~:text=mp4split%20,iss.drm_specific_data%3D%24%7BPR_PSSH%7D)). We also passed a Widevine PSSH using `--widevine.drm_specific_data` (assuming we had a base64-encoded PSSH blob from our license provider). The first command outputs `video_enc.cmfv` which is the encrypted video fragments, and the second outputs `audio_enc.cmfa` for audio. The packager will automatically choose a fragment length based on default or you can specify one (e.g., `--fragment_duration`). If encryption is successful, these files are now CENC encrypted (they contain the PSSH and are not playable without a license). If you open them in a hex editor, you'd see `pssh` boxes and `senc` sample encryption boxes.

2. **Generate the DASH MPD file:** Now create an MPD that references those encrypted fragments:

```bash
   mp4split --package_mpd -o stream.mpd video_enc.cmfv audio_enc.cmfa
```

   This tells `mp4split` to package for DASH, outputting `stream.mpd`, using the given media files ([Packaging for MPEG-DASH — Unified Streaming](https://docs.unified-streaming.com/documentation/package/mpeg-dash.html#creating-the-media-presentation-description-file-mpd#:~:text=mp4split%20,dash.cmfv)). The tool will scan `video_enc.cmfv` and `audio_enc.cmfa` and generate a proper MPD. Because those files contain encryption, the MPD will include `<ContentProtection>` elements for CENC. In our case, since we included Widevine data, it might include something like:

```xml
   <ContentProtection
       schemeIdUri="urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed"
       value="Widevine">
     <cenc:pssh>...(base64 PSSH)...</cenc:pssh>
   </ContentProtection>
   <ContentProtection
       schemeIdUri="urn:uuid:9a04f079-9840-4286-ab92-e65be0885f95"
       value="PlayReady">
     <cenc:pssh>...(base64 PlayReady PSSH, if provided)...</cenc:pssh>
   </ContentProtection>
   <ContentProtection schemeIdUri="urn:mpeg:dash:mp4protection:2011" value="cenc"
       cenc:default_KID="ABCDE123-4567-890A-BCDE-1234567890AB"/>
```
   and so on, inside the MPD. The MPD will also list two AdaptationSets (one for video, one for audio) each with one Representation, including the bandwidth, codec info (e.g., `codecs="avc1.640028"` for video), segment template or list, etc. Now, `stream.mpd` along with `video_enc.cmfv` and `audio_enc.cmfa` constitute a DASH stream. A DASH player like Shaka can play it, but will request a Widevine or PlayReady license (depending on the device) using the PSSH info.

3. **Test the DASH output:** Use a DASH test player (e.g., the DASH-IF Reference Player or Shaka Player) to load `stream.mpd`. You'll need to provide it with a license server URL for Widevine/PlayReady in the player config. If everything is packaged correctly, the player should be able to obtain a license and start playback. If it fails, check the console/logs – e.g., a **401/403 from license server** means the packaging might be fine, but maybe the key or KID is not recognized by the license server (ensure you used the right values). If the player says "Error parsing MPD" or "No compatible Representation", validate the MPD with a DASH validator. Also ensure the MP4s had compatible codecs (e.g., both video and audio use codec profiles the target player supports, and the MPD's `mimeType`/`codecs` attribute is correct). `mp4split` usually gets this right automatically.

4. *(Optional)* **Multiple DRM signaling:** If you wanted to include PlayReady as well (and you have the PlayReady LA_URL or PSSH), you could add `--playready.la_url=<LicenseURL>` to the `mp4split --package_mpd` command, or include a PlayReady PSSH in the video packaging step. Alternatively, you could have provided an MPEG-CENC multi-system CPIX file to the packaging step. But the above example demonstrates the basics with one key.

This example shows how to go from raw MP4 to an encrypted DASH stream in just a couple of commands. It highlights the power of `mp4split` to handle encryption and manifest generation seamlessly.

**Example 3: Adding subtitles to a stream (DASH or HLS)**
Suppose you have an **SRT subtitle file** for a movie (English subtitles in `movie.en.srt`). You want to include this in your packaged outputs.

1. **Convert SRT to a segmented format:** Use `mp4split` to convert the SRT into a fragmented MP4 subtitle track:

```bash
   mp4split -o subs-en.cmft movie.en.srt --track_language=eng
```

   Here, `subs-en.cmft` is the output fragmented text track ([Packaging for MPEG-DASH — Unified Streaming](https://docs.unified-streaming.com/documentation/package/mpeg-dash.html#creating-the-media-presentation-description-file-mpd#:~:text=mp4split%20,track_language%3Deng)), and we tag it with language "eng". This creates a file containing the subtitles timed to the movie. It essentially took each subtitle cue, timed it, and put it into segments inside an MP4 container. If the source SRT's timing didn't start at 0, `mp4split` will handle the offset appropriately. We now have subtitles in a format ready for DASH (and potentially HLS if using fMP4 subtitles or converting to WebVTT).

2. **Package with video and audio (for DASH):** If you continue with the previous example's `stream.mpd`, you can add this subtitle track. Re-run the MPD packaging including the subtitle:

```bash
   mp4split --package_mpd -o stream_with_subs.mpd \
       video_enc.cmfv audio_enc.cmfa subs-en.cmft
```

Now the MPD will have an additional AdaptationSet for subtitles (with lang="eng" and perhaps role="subtitle"). Many DASH players will automatically load it and provide a toggle for the user. If encryption was used for video/audio, note we did not encrypt the subtitles here (typically subtitles are left clear even in DRM scenarios, unless you have reasons to protect them). The MPD ContentProtection might not appear under the text AdaptationSet (which is fine since it's clear). Make sure your player supports TTML/IMSC1 in MP4. If not (some players only like WebVTT), you could convert SRT to WebVTT instead: e.g., `mp4split -o subs-en.vtt movie.en.srt` to get a WebVTT file, and then reference that in the MPD as an `<AdaptationSet mimeType="text/vtt">` with an external `BaseURL`. However, doing that might require editing the MPD or using the `--mpd.insert_externals` option if available. Sticking to MP4 subtitles (IMSC1) is a clean approach for DASH.

For HLS, the process would differ slightly: you could convert SRT to WebVTT and then use the HLS master playlist approach. For instance, `mp4split -o subs-en.vtt movie.en.srt` to get WebVTT, then modify the HLS master to include: `#EXT-X-MEDIA:TYPE=SUBTITLES,GROUP-ID="subs",NAME="English",LANGUAGE="en",URI="subs-en.vtt"` (if using HLS with WebVTT). Currently, `mp4split` doesn't automatically generate the WebVTT playlist – you provide the .vtt directly. Alternatively, `mp4split` *can* produce an HLS text media playlist with fMP4 segments if you package the .cmft into HLS: e.g., `mp4split --package_hls -o subs/prog_index.m3u8 subs-en.cmft`. This would yield an HLS playlist for the subtitles (with segments, using MP4 segments for text). Then you'd tie that into the master as SUBTITLES type pointing to subs/prog_index.m3u8. The Unified docs describe adding WebVTT subtitles to HLS TS streams as well ([Unified Packager — Unified Streaming](https://docs.unified-streaming.com/documentation/package/index.html#:~:text=version%205%29%20%20,subtitles%20when%20packaging%20HLS%20TS)).

3. **Verify subtitle inclusion:** Play back the new MPD (or HLS master if that route). You should see an option for English subtitles. If not, inspect the manifest to ensure the subtitle track is listed. In DASH, check that the AdaptationSet has `<Role value="subtitle"/>` or `<Role value="caption"/>` and the proper mimeType (`application/mp4` with codecs like `stpp` for TTML). One common issue is some players might not show subtitles if mimeType/codecs aren't what they expect. Unified Packager uses `codecs="stpp"` for TTML (IMSC1) in MP4 and `codecs="wvtt"` for WebVTT in MP4. Make sure your player supports the one you used. If not, you might switch to WebVTT out-of-band.

4. **Multiple languages:** If you had more languages, repeat the process for each (e.g., `movie.es.srt` for Spanish to `subs-es.cmft`). You can include multiple subtitle AdaptationSets or in HLS, list multiple EXT-X-MEDIA entries for subtitles. The packager will take each input subtitles file and treat it as a separate track in the manifest when you do the final manifest packaging.

This example demonstrates how `mp4split` aids in integrating subtitles. The key is converting them into the right format and then including them as inputs during manifest creation.

**Example 4: Quick VOD -> HLS packaging (end-to-end)**
For a simple end-to-end scenario, imagine you have a single MP4 `trailer.mp4` and you want to generate an HLS stream (TS segments) from it, without multiple bitrates (just one stream).

1. **Single-command packaging:** You can actually do this in one command:

```bash
   mp4split --package_hls -o trailer.m3u8 trailer.mp4
```

This will produce `trailer.m3u8` and the corresponding `.ts` segment files in the same directory. The output playlist is a complete HLS presentation for the one bitrate. You can directly host `trailer.m3u8` and the .ts files. This is effectively "packaging MP4 to HLS" in one step. The playlist will be a variant playlist with no alternates (just the one media playlist which is itself the master in this case, since no separate master is needed with one variant).

2. **Review output:** Open `trailer.m3u8` in a text editor to verify it looks correct (has `#EXTM3U`, `#EXT-X-TARGETDURATION`, a sequence of `#EXTINF` entries summing up to the video length, and no obvious errors). Also check that segment files (likely named `trailer1.ts`, `trailer2.ts`, etc., by default) exist.

3. **Play the HLS stream:** Because it's only one rendition, you can test it in a player like VLC or any HLS player. It should play through from start to finish. If you needed to encrypt it (AES-128), you would add options like `--hls.key <key>` and `--hls.key_uri <URI>`; `mp4split` would then produce an `#EXT-X-KEY` in the playlist and the segments would be encrypted with that key.

This example shows the simplest use-case and confirms that `mp4split` can handle even a quick one-off packaging without complex setup.

---

Through these examples, we saw how to use `mp4split` in various workflows: multi-bitrate HLS, DASH with DRM, adding subtitles, and a basic one-shot HLS package. In each case, the process involves choosing the right options and possibly doing things in stages (especially for multi-bitrate). By combining the commands appropriately, Unified Packager covers a wide range of streaming preparation tasks. Always refer back to the documentation for more nuanced scenarios (like packaging for low-latency streaming, using trick-play tracks, or cloud storage integration), but the above should serve as a strong foundation for the most common packaging needs.